/*
    sarpd -- criptographic functions

    Copyright (C) 2002  ALoR <alor@blackhats.it>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

*/

#include <sad_main.h>
#include <sad_crypto.h>
#include <sad_inet.h>

#include <openssl/rand.h>
#include <openssl/dsa.h>
#include <openssl/bio.h>
#include <openssl/evp.h>

/* globals */


/* protos */

void crypto_init(void);
void crypto_precomp(void);
void crypto_sign(u_char *data, int datalen, u_char *sign, u_int32 *siglen);
int crypto_verify_sign(u_char *data, int datalen, u_char *sig, int siglen, DSA *key);
void crypto_load_sarp_file(char *filename, u_int32 *ip_addr, u_char *ll_addr, DSA **dsa);

DSA * DSA_dup(DSA *src);

/*******************************************/

void crypto_init(void)
{
   /*
    * feed the RND with entropy
    */
        
#ifdef HAVE_DEV_URANDOM
   RAND_load_file("/dev/urandom", 1024);
#elif defined(HAVE_DEV_RANDOM) 
   RAND_load_file("/dev/random", 1024);
#else
#warning randomness source not found !!
#endif
  
   if (RAND_status() != 1)
      ERROR_MSG("RAND has NOT been seeded with enough data");

   DEBUG_MSG("crypto_init : calculating DSA kinv and r");

   /* speed up the signing process */
   
   crypto_precomp();
   
   /*
    * store the lenght of the signature
    * generated by our key
    */
   
   GBL_CRYPTO_SIGLEN = DSA_size(GBL_CRYPTO_KEY);
   
   DEBUG_MSG("crypto_init : initialized | our key is %d bits", BN_num_bits(GBL_CRYPTO_KEY->p));
}

/*
 * precalculate kinv and r parameter to speed
 * up the signing process
 */

void crypto_precomp(void)
{
   DSA_sign_setup(GBL_CRYPTO_KEY, NULL, 
                  &GBL_CRYPTO_KEY->kinv, 
                  &GBL_CRYPTO_KEY->r);
}


void crypto_sign(u_char *data, int datalen, u_char *sign, u_int32 *siglen)
{
   u_char sha[SHA_DIGEST_LENGTH];
   DEBUG_TIME_DECLARATION;
   
   DEBUG_MSG("crypto_sign");
 
   DEBUG_TIME_INIT();
   
   SHA1(data, datalen, sha);
   
   DEBUG_TIME_PRINT("SHA-1 time:");
   DEBUG_TIME_INIT();
   
   if ( DSA_sign(0, sha, SHA_DIGEST_LENGTH, sign, siglen, (DSA *)GBL_CRYPTO_KEY) == -1 )
      ERROR_MSG("Can't sign with MY key");
      
   DEBUG_TIME_PRINT("DSA_sign time:");
}

/*
 * verify a signature
 * return: ESARP_SUCCESS on success
 *         -ESARP_KEYMISMATCH on failure
 */

int crypto_verify_sign(u_char *data, int datalen, u_char *sig, int siglen, DSA *key)
{
   u_char sha[SHA_DIGEST_LENGTH];
   DEBUG_TIME_DECLARATION;
   
   DEBUG_TIME_INIT();
   
   SHA1(data, datalen, sha);
   
   DEBUG_TIME_PRINT("SHA-1 time:");
   DEBUG_TIME_INIT();
   
   if ( DSA_verify(0, sha, SHA_DIGEST_LENGTH, sig, siglen, key) != 1 ) {
      DEBUG_MSG("crypto_verify_sign : FAILED");
      return -ESARP_KEYMISMATCH;
   }
   
   DEBUG_TIME_PRINT("DSA_verify time:");
   
   DEBUG_MSG("crypto_verify_sign : success");
   return ESARP_SUCCESS;
}

/*
 * load the IP, LL_ADDR and the DSA key
 * from a .sarp file
 */

void crypto_load_sarp_file(char *filename, u_int32 *ip_addr, u_char *ll_addr, DSA **dsa)
{
   FILE *fd;
   char line[128];
   char *pub;
   u_char *ptr, *buf;
   int len, read_pub = 0;
   u_char *sig;
   int siglen;
   char message[1024];
   
   DEBUG_MSG("crypto_load_sarp_file %s", filename);
   
   pub = calloc(1, sizeof(char));
   
   fd = fopen(filename, "r");
   ON_ERROR(fd, "Can't read %s", filename);
           
   while(fgets(line, 128, fd)) {
   
      if (!strncmp(line, "IP: ", 4))
         *ip_addr = inet_addr(line + 4);
              
      if (!strncmp(line, "LL: ", 4))
         memcpy(ll_addr, ha_aton(line + 4), LL_ADDR_LEN);
      
      if (line[0] == '-') {
         read_pub++;
         continue;    /* skip header and trailer */
      }
      
      if (read_pub == 1) {
         pub = realloc(pub, strlen(pub) + strlen(line) + 1);
         ON_ERROR(pub, "can't allocate memory");
      
         strcat(pub, line);
      }
   }
   
   fclose(fd);

   len = b64_to_raw(pub, &ptr);
   
   /*
    * create a dsa from private key
    */
   
   buf = ptr;
   if ( (*dsa = d2i_DSAPublicKey(NULL, &buf, len)) == NULL)
      ERROR_MSG("Can't convert from DER");
   
   SAFE_FREE(ptr);
   
   /*
    * do a validation of the data
    * check the signature.
    * the signature has been introduced to be
    * sure that the owner of the private key
    * is conscious of its IP address
    */
   
   sprintf(message, SARP_FILE_FORMAT_STRING, 
                    pa_ntoa((u_char *)ip_addr), 
                    ha_ntoa(ll_addr), 
                    pub);
   
   SAFE_FREE(pub);

   /*
    * the last line is the signature...
    */
   
   siglen = b64_to_raw(line, &sig);
  
   if (crypto_verify_sign(message, strlen(message), sig, siglen, *dsa) == -ESARP_KEYMISMATCH)
      ERROR_MSG("The sarp file [%s] is not correctly self-signed", filename);
   
   SAFE_FREE(sig);
   
   DEBUG_MSG("crypto_load_sarp_file result: 0x%08x %s", *ip_addr, ha_ntoa(ll_addr));
}

/*
 * duplicate a DSA structure
 */

DSA * DSA_dup(DSA *src)
{
   DSA *dst;
   int len;
   char buf[1024];
   u_char *ptr;
   
   ptr = buf;
   if (src->priv_key == NULL) {
      if ( (len = i2d_DSAPublicKey(src, &ptr)) == 0) 
         ERROR_MSG("Can't convert to DER");
   } else {
      if ( (len = i2d_DSAPrivateKey(src, &ptr)) == 0) 
         ERROR_MSG("Can't convert to DER");
   }

   ptr = buf;
   if (src->priv_key == NULL) {
      if ( (dst = d2i_DSAPublicKey(NULL, &ptr, len)) == NULL)
         ERROR_MSG("Can't convert from DER");
   } else {
      if ( (dst = d2i_DSAPrivateKey(NULL, &ptr, len)) == NULL)
         ERROR_MSG("Can't convert from DER");
   }
   
   return dst;
}


/* EOF */

// vim:ts=3:expandtab

